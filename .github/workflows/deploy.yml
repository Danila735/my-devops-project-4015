name: Deploy 4015 Hits to Yandex Cloud

# Триггер: запускать при каждом push в ветку main
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version:
        description: 'Какую версию деплоим?'
        required: true
        default: 'latest'

jobs:

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          pip install flask psycopg2-binary

      - name: Run Syntax Check
        run: |
          # Это наш простенький тест: если в коде опечатка, он упадет
          python3 -m py_compile app/main.py

  build-and-push:
    needs: test # Запускать только если тесты прошли!
    if: github.event_name == 'push' || github.event.inputs.version == 'latest' || github.event.inputs.version == ''
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      # генерируем SHA (чтобы Гитхаб узнал этот номер)
      - name: Set short SHA
        id: vars
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      # 1. Логинимся в Яндекс.Реестр
      - name: Login to Yandex Container Registry
        uses: docker/login-action@v2
        with:
          registry: cr.yandex
          username: json_key
          password: ${{ secrets.YC_SA_JSON_KEY }}

      # 2. Собираем и пушим образ нашего приложения
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v4
        with:
          context: ./app
          push: true
          # Обрати внимание на путь: cr.yandex/ID_РЕЕСТРА/имя:тег
          tags: |
            cr.yandex/${{ secrets.YC_REGISTRY_ID }}/my-app:latest
            cr.yandex/${{ secrets.YC_REGISTRY_ID }}/my-app:${{ steps.vars.outputs.sha_short }}
            cr.yandex/${{ secrets.YC_REGISTRY_ID }}/my-app:v${{ github.run_number }}

  deploy:
    needs: build-and-push
    if: |
      always() && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      # 1. Забираем код в Гитхаб (чтобы было что копировать)
      - uses: actions/checkout@v3

      # 2. Копируем файл docker-compose.yml прямо на сервер
      - name: Copy docker-compose via SCP
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.SSH_KEY }}
          source: "docker-compose.yml,nginx/nginx.conf,prometheus.yml"
          target: "/home/ubuntu/my_app" # Файл ляжет в ~/my_app/docker-compose.yml

      # 3. Заходим по SSH и даем команду на старт
      - name: Deploy via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd ~/my_app

            SELECTED_VERSION="${{ github.event.inputs.version }}"
            APP_TAG=${SELECTED_VERSION:-latest}

            echo "Деплоим версию: $APP_TAG"

            # Обновляем .env и ID реестра
            echo "${{ secrets.ENV_FILE }}" > .env
            echo "YC_REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }}" >> .env
            echo "GRAFANA_PASSWORD=${{ secrets.GRAFANA_PASSWORD }}" >> .env

            # Логинимся в реестр на сервере (паспорт)
            echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login --username json_key --password-stdin cr.yandex

            # Стягиваем готовый образ и запускаем
            docker compose pull
            docker compose up -d

            # 5. Ждем 10 секунд, чтобы база и питон успели "проснуться"
            sleep 10
 
            # 6. SMOKE TEST: Бьем по localhost внутри сервера
            echo "Запускаю Smoke Test..."
            if curl -s localhost | grep -q "Визит"; then
              echo "ТЕСТ ПРОЙДЕН: Приложение ответило правильно!"
            else
              echo "ТЕСТ ПРОВАЛЕН: Приложение не отдает визиты!"
              docker compose logs # Посмотрим, что пошло не так
              exit 1
            fi
            docker image prune -f
